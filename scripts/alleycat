import argparse
import json
import sys

import collections
from alleycat import graph as g
from alleycat import helpers as hlp
from alleycat.actors import cat as c, human as h

MAX_TURNS = 1e5


class Board(object):
    """
    This is the board where the whole simulation takes place.

    It knows the map (Graph) and the actors (Cats and Humans)
    and knows the matches between the two.
    """

    def __init__(self, connections_json_file, stations_json_file=None):
        with open(connections_json_file) as f:
            connections_list = json.load(f)

        # The current turn of the simulation
        self.turn = 0

        # The number of turns a station remains closed
        self._closing_turns = None

        self.map = g.Graph(connections_list=connections_list)

        # This is the list of all actors on the board
        self.actors = []

        # This is the list of (owner, cat) tuples
        self.chasing = []

        # This is the list of spawned (owner, cat) tuples
        self.spawned = []

        # This is the list of (owner, cat) tuples that rejoined
        self.successful = []

        # This is the list of "trapped" actors, i.e. stuck in a closed station
        self.trapped = []

        # This is a dictionary of closed stations, the value is the closing turn
        self.closed_stations = {}

        self.station_names = {}
        if stations_json_file:
            with open(stations_json_file) as f:
                stations_list = json.load(f)

            self.station_names = dict((index, name) for index, name in stations_list)

    def _station_code2name(self, code):
        try:
            return self.station_names[code]
        except KeyError:
            return code

    def _close_station(self, code):
        self.map.remove_node_connections(code)
        self.closed_stations[code] = self.turn

    def _open_station(self, code):
        self.map.restore_node_connections(code)
        self.closed_stations.pop(code)

    @property
    def closing_turns(self):
        return self._closing_turns

    @closing_turns.setter
    def closing_turns(self, num):
        self._closing_turns = int(num)

    def spawn_cats_and_owners(self, num):
        # This function can be called even during the game

        # Get couples of random different positions
        positions = hlp.get_random_couples(num, self.map.get_nodes())

        for owner_position, cat_position in positions:
            owner = h.Human(name=len(self.chasing), position=owner_position)
            cat = c.Cat(name=len(self.chasing), position=cat_position)

            self.actors.append(owner)
            self.actors.append(cat)
            self.chasing.append((owner, cat))
            self.spawned.append((owner, cat))

    def run_single_turn(self):
        # This runs one single turn of the game

        for actor in self.actors:
            # Find possible locations for the next position
            positions = self.map.get_node_neighbours(actor.position)

            if len(positions) == 0 and actor not in self.trapped:
                self.trapped.append(actor)

            # Move the actor
            actor.travel(positions)

        # This checks if some couple met or moved too many times
        finished_couples = []
        for owner, cat in self.chasing:
            station = self._station_code2name(owner.position)

            if owner.position == cat.position:
                # Remove it from the game
                finished_couples.append((owner, cat))

                # Release love!
                print("Turn {turn} - Owner {name} found their cat! - Station {station} is now closed".format(
                    turn=self.turn,
                    name=owner.name,
                    station=station))
                self._close_station(owner.position)

        return finished_couples

    def run(self):
        while len(self.actors) != 0:
            if self.turn == MAX_TURNS:
                break

            finished_couples = self.run_single_turn()
            self.turn += 1

            # Record finished couples
            for owner, cat in finished_couples:
                self.actors.remove(owner)
                self.actors.remove(cat)
                self.chasing.remove((owner, cat))
                self.successful.append((owner, cat))

            # Check closed stations
            if self.closing_turns is not None:
                opening_stations = [station for station, turn in self.closed_stations.items() if
                                    self.turn - turn > self.closing_turns]
                for station in opening_stations:
                    print("Turn {turn} - Station {station} reopens clean and shiny".format(
                        turn=self.turn,
                        station=self._station_code2name(station),
                    ))
                    self._open_station(station)

        # Average number of moves of successful owners
        avg_moves = int(sum([owner.moves for owner, cat in self.successful]) / len(self.successful))

        # Most visited station
        all_visited_stations = collections.Counter()
        for owner, cat in self.spawned:
            all_visited_stations.update(owner.visited_positions)

        print()
        print("##### SUMMARY #######")
        print()
        print("Total number of cats in play:", len(self.spawned))
        print("Total number of cats found:", len(self.successful))
        print("Average number of movements required to find a cat:", avg_moves)
        print()
        print("Most visited stations:")
        for index, visits in all_visited_stations.most_common()[:3]:
            print("  * {} had {} visits".format(self._station_code2name(index), visits))
        print()


parser = argparse.ArgumentParser(description="Simulates a cat chase in London")
parser.add_argument('-c', '--connections-file', action='store',
                    help="Connections file (JSON)")
parser.add_argument('-s', '--stations-file', action='store',
                    help="Stations file (JSON)")
parser.add_argument('--closing-turns', action='store',
                    help="Number of turns a station remains closed")
parser.add_argument('--verbose', action='store_true',
                    help="Be verbose")

args = parser.parse_args()

if args.connections_file is None:
    print("Please specify a connections file. Use --help to list available options.")
    sys.exit(1)

b = Board(args.connections_file, args.stations_file)
b.closing_turns = args.closing_turns
b.spawn_cats_and_owners(200)

b.run()
